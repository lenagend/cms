# 🚀 Backend Core Modules

이 프로젝트는 **바로 상용 환경에 투입 가능한 CMS 백엔드**를 목표로 만들어졌습니다.

전자정부 프레임워크 기반의 오래되고 비효율적인 CMS들을 유지보수·개선·운영하며 반복적으로 겪었던 문제들이 출발점입니다.

* **변경 하나에 전체 시스템이 흔들리는 구조**
* **비즈니스 로직과 인프라 설정이 뒤엉킨 코드**
* **기능은 늘어나는데 유지보수 비용은 기하급수적으로 증가하는 패턴**
* **“지금은 되지만 다음은 감당 안 되는” 설계**

이 프로젝트는 그런 **낡은 CMS 설계 방식에서 벗어나기 위해**, 아래 원칙을 기준으로 설계되었습니다.

* **실제 운영과 유지보수를 전제로 할 것**
* **기능 추가가 구조 붕괴로 이어지지 않을 것**
* **인프라·보안·멀티테넌시가 초기부터 고려될 것**
* **특정 프레임워크 관성에 종속되지 않을 것**

---

## 1. 📝 JPA Audit Module

### 무엇을 하는가
엔티티의 생성 시각, 수정 시각, 생성자 및 수정자 정보를 시스템 전역에서 공통으로 관리합니다. 단순 시간 기록을 넘어, 스프링 시큐리티의 인증 컨텍스트와 연동하여 실제 데이터를 조작한 주체를 추적합니다.

### 왜 이렇게 설계했는가
기존 CMS처럼 엔티티마다 audit 필드를 중복 정의하거나 비즈니스 로직에서 시간을 직접 세팅하는 책임 혼재를 제거하기 위함입니다. `@EnableJpaAuditing`과 `AuditorAware`를 통해 영속성 계층에서 감사 로직을 분리하여 **데이터의 투명성**을 확보했습니다.

### 사용 방법
엔티티 클래스에서 `BaseAuditEntity`를 상속받기만 하면 됩니다. 데이터 생성/수정 시 로그인된 사용자의 ID가 자동으로 `created_by`, `updated_by` 필드에 할당되며, 인증 정보가 없는 경우 `SYSTEM`으로 기록됩니다.

---

## 2. ⚡ Async Execution Module

### 무엇을 하는가
애플리케이션 전반의 비동기 실행 환경을 관리하며, **Java 21의 가상 스레드(Virtual Threads)**를 사용하여 고성능 비동기 처리를 수행합니다.

### 왜 이렇게 설계했는가
기존 스레드 풀 방식의 리소스 점유 문제를 해결하기 위해 경량 스레드인 가상 스레드 방식을 채택했습니다. 또한, 비동기 작업 시 유실되기 쉬운 로깅 문맥(MDC)과 테넌트 정보(`TenantContext`)를 `TaskDecorator`를 통해 자식 스레드로 안전하게 전파하도록 설계했습니다.

### 사용 방법
비동기 처리가 필요한 메서드에 `@Async`를 사용합니다. 별도의 실행 정책 설정 없이도 시스템이 자동으로 가상 스레드를 할당하며, 비즈니스 로직 내에서 **현재 접속 중인 테넌트 정보**나 추적 ID를 그대로 사용할 수 있습니다.

---

## 3. 🔍 MDC Logging Module

### 무엇을 하는가
모든 HTTP 요청에 대해 유일한 추적 ID(Correlation ID)를 부여하고 이를 로그 컨텍스트에 자동으로 주입합니다.

### 왜 이렇게 설계했는가
수많은 요청이 뒤섞이는 환경에서 특정 사용자의 요청 흐름만 필터링하여 추적하기 위함입니다. 서비스 코드 곳곳에서 식별자를 직접 출력하는 코드 오염을 방지하고, 전역 필터 레이어에서 로깅 책임을 분리하여 **일관된 로그 포맷**을 유지합니다.

### 사용 방법
`MdcLoggingFilter`가 요청 진입점에서 자동으로 ID를 발급하거나 클라이언트의 헤더(`X-Correlation-ID`)를 검증하여 MDC에 저장합니다. 응답 헤더에도 해당 ID를 포함하여 클라이언트가 장애 문의 시 활용할 수 있게 합니다.

---

## 4. 🚦 Rate Limiting Module

### 무엇을 하는가
API 호출 빈도를 제한하여 시스템 과부하와 악성 트래픽에 의한 남용을 방지합니다.

### 왜 이렇게 설계했는가
정책과 구현을 분리하여 단일 서버(Local) 및 분산 환경(Redis)에 유연하게 대응하기 위함입니다. 레디스 장애 시에도 서비스를 지속하는 **Fail-Open 정책**과 신뢰할 수 있는 프록시 IP만 검증하는 보안 로직을 포함하여 가용성과 보안을 동시에 고려했습니다.

### 사용 방법
설정(`RateLimitProperties`)을 통해 활성화 여부와 허용량을 제어합니다. 모든 요청은 전역 필터를 거치며 정책에 따라 토큰 소모 여부를 판단하고, 초과 시 `429 Too Many Requests` 응답과 함께 재시도 가능 시간을 안내합니다.

---

## 5. 🛡 Security & Authentication Module

### 무엇을 하는가
인증, 인가 및 로그인 흐름 전반을 구성하며, API와 WEB 경로에 대해 분리된 보안 정책을 적용합니다.

### 왜 이렇게 설계했는가
Stateless한 API와 세션 기반의 WEB 환경은 보안 요구사항이 다르기 때문입니다. 각 단계를 핸들러와 엔트리포인트로 분리하여 **Open Redirect 취약점**을 방어하고, AJAX/API 요청 여부에 따라 응답 형식을 스마트하게 분기하여 처리 효율을 높였습니다.

### 사용 방법
`/api/**` 경로는 무상태 보안이, 그 외 경로는 폼 로그인과 세션 관리가 적용됩니다. 로그인 성공 시 `FormAuthenticationSuccessHandler`가 안전한 URL인지 검증 후 리다이렉트하며, 실패 시 전문 핸들러가 사유를 분석하여 처리합니다.

---

## 6. 🧹 XSS Protection Module

### 무엇을 하는가
요청 데이터 전반에 대해 XSS(Cross-Site Scripting) 공격을 방어하며, HTML 태그를 정제합니다.

### 왜 이렇게 설계했는가
단순 문자열 치환이 아닌 `Jsoup` HTML 파서를 사용하여 강력하게 태그를 발라내기 위함입니다. 또한, CMS 특성상 본문 에디터 등 HTML 허용이 필요한 구간을 위해 **`@AllowHtml` 어노테이션**과 설정을 통한 선언적 예외 처리가 가능하도록 설계했습니다.

### 사용 방법
대부분의 Form 데이터는 `XssRequestWrapper`에 의해 정제됩니다. JSON 데이터의 경우 `XssJacksonDeserializer`가 처리하며, HTML 허용이 필요한 DTO 필드에 `@AllowHtml`을 붙여 선택적으로 방어 정책을 조절합니다.

---

## 7. 🏢 Multi-Tenancy Module

### 무엇을 하는가
요청 단위로 도메인을 분석하여 테넌트(사이트)를 식별하고 컨텍스트를 유지합니다.

### 왜 이렇게 설계했는가
테넌트 정보를 파라미터로 매번 전달하는 복잡도를 제거하고 인프라 레벨에서 자동화하기 위함입니다. `AntPathMatcher`를 이용한 와일드카드 도메인 매칭과 **이중 캐싱 전략(Rule Map + Caffeine)**을 사용하여 고성능 테넌트 식별 구조를 구축했습니다.

### 사용 방법
`TenantFilter`가 요청 진입점에서 사이트 코드를 결정하여 `TenantContext`에 바인딩합니다. 서비스 로직에서는 파라미터 전달 없이 `TenantContext.getSiteCode()`를 통해 현재 테넌트 정보를 참조할 수 있습니다.

---

## 8. 👤 User Domain Module

### 무엇을 하는가
시스템 전체의 사용자 계정(Identity)과 상태, 소셜 연동 정보를 관리합니다.

### 왜 이렇게 설계했는가
계정의 신원 정보와 특정 사이트에서의 활동 정보를 분리하여 **N:M 구조의 멀티테넌시 환경**에 대응하기 위함입니다. 계정 상태(Active, Locked 등)를 세분화하여 보안성을 높이고, 소셜 연동 정보를 별도 엔티티로 분리하여 확장성을 확보했습니다.

### 사용 방법
이메일을 고유 식별자로 사용하여 전역 계정을 관리합니다. 사용자의 로그인 성공/실패 횟수 및 최종 로그인 시점은 `User` 엔티티 내에서 관리되며, 시큐리티 인증 시 핵심 정보로 활용됩니다.

---

## 9. 🏷 Attribute & Membership Module

### 무엇을 하는가
사용자의 동적 프로필 속성과 특정 테넌트에 속한 멤버십(권한 및 상태)을 정의합니다.

### 왜 이렇게 설계했는가
사이트마다 다른 사용자 속성을 수집할 때 테이블 스키마 변경 없이 대응하기 위해 **JSON 타입의 동적 속성 구조**를 채택했습니다. 또한 유저와 테넌트 사이의 연결점인 멤버십을 통해 사이트별로 상이한 권한(`Role`)을 부여할 수 있도록 설계했습니다.

### 사용 방법
`UserAttributeDefinition`으로 속성 스펙을 정의하면 `UserProfile`의 JSON 필드에 데이터가 저장됩니다. 특정 사이트 접근 시 `MembershipRepository`를 통해 해당 테넌트에서의 유효한 권한을 확인하여 인가 처리를 수행합니다.